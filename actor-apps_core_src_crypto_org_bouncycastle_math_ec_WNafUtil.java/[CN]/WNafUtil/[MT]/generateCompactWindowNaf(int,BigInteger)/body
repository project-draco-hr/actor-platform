{
  if (width == 2) {
    return generateCompactNaf(k);
  }
  if (width < 2 || width > 16) {
    throw new IllegalArgumentException("'width' must be in the range [2, 16]");
  }
  if ((k.bitLength() >>> 16) != 0) {
    throw new IllegalArgumentException("'k' must have bitlength < 2^16");
  }
  if (k.signum() == 0) {
    return EMPTY_INTS;
  }
  int[] wnaf=new int[k.bitLength() / width + 1];
  int pow2=1 << width;
  int mask=pow2 - 1;
  int sign=pow2 >>> 1;
  boolean carry=false;
  int length=0, pos=0;
  while (pos <= k.bitLength()) {
    if (k.testBit(pos) == carry) {
      ++pos;
      continue;
    }
    k=k.shiftRight(pos);
    int digit=k.intValue() & mask;
    if (carry) {
      ++digit;
    }
    carry=(digit & sign) != 0;
    if (carry) {
      digit-=pow2;
    }
    int zeroes=length > 0 ? pos - 1 : pos;
    wnaf[length++]=(digit << 16) | zeroes;
    pos=width;
  }
  if (wnaf.length > length) {
    wnaf=trim(wnaf,length);
  }
  return wnaf;
}
