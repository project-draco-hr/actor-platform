{
  int seq;
  byte[] state;
  int type;
  byte[] body;
  if (u instanceof SeqUpdate) {
    seq=((SeqUpdate)u).getSeq();
    state=((SeqUpdate)u).getState();
    type=((SeqUpdate)u).getUpdateHeader();
    body=((SeqUpdate)u).getUpdate();
  }
 else   if (u instanceof FatSeqUpdate) {
    seq=((FatSeqUpdate)u).getSeq();
    state=((FatSeqUpdate)u).getState();
    type=((FatSeqUpdate)u).getUpdateHeader();
    body=((FatSeqUpdate)u).getUpdate();
  }
 else   if (u instanceof WeakUpdate) {
    WeakUpdate w=(WeakUpdate)u;
    Log.d(TAG,"Received weak update");
    try {
      processor.processWeakUpdate(parser.read(w.getUpdateHeader(),w.getUpdate()),w.getDate());
    }
 catch (    IOException e) {
      e.printStackTrace();
      Log.w(TAG,"Unable to parse update: ignoring");
    }
    return;
  }
 else   if (u instanceof InternalUpdate) {
    Log.d(TAG,"Received internal update");
    processor.processInternalUpdate((InternalUpdate)u);
    return;
  }
 else   if (u instanceof ExecuteAfter) {
    ExecuteAfter after=(ExecuteAfter)u;
    if (after.getSeq() <= this.seq) {
      after.getRunnable().run();
    }
 else {
      pendingRunnables.add(after);
    }
    return;
  }
 else   if (u instanceof PushSeq) {
    PushSeq pushSeq=(PushSeq)u;
    if (pushSeq.seq <= this.seq) {
      Log.d(TAG,"Ignored PushSeq {seq:" + pushSeq.seq + "}");
    }
 else {
      Log.w(TAG,"External Out of sequence: starting timer for invalidation");
      self().sendOnce(new ForceInvalidate(),INVALIDATE_GAP);
    }
    return;
  }
 else {
    return;
  }
  if (seq <= this.seq) {
    Log.d(TAG,"Ignored SeqUpdate {seq:" + seq + ", currentSeq: "+ this.seq+ "}");
    return;
  }
  Log.d(TAG,"SeqUpdate {seq:" + seq + "}");
  if (!isValidated) {
    Log.d(TAG,"Caching in further map");
    further.put(seq,u);
    return;
  }
  if (!isValidSeq(seq)) {
    further.put(seq,u);
    if (seq - this.seq > INVALIDATE_MAX_SEC_HOLE) {
      Log.w(TAG,"Out of sequence: Too big hole. Force invalidate immediately");
      self().sendOnce(new ForceInvalidate());
      return;
    }
    if (isTimerStarted) {
      Log.w(TAG,"Out of sequence: timer already started");
    }
 else {
      Log.w(TAG,"Out of sequence: starting timer for invalidation");
      self().sendOnce(new ForceInvalidate(),INVALIDATE_GAP);
      isTimerStarted=true;
    }
    return;
  }
  Update update;
  try {
    update=new UpdatesParser().read(type,body);
  }
 catch (  IOException e) {
    Log.w(TAG,"Unable to parse update: ignoring");
    e.printStackTrace();
    return;
  }
  if ((!(u instanceof FatSeqUpdate)) && processor.isCausesInvalidation(update)) {
    Log.w(TAG,"Message causes invalidation");
    invalidate();
    return;
  }
  Log.d(TAG,"Processing update: " + update);
  if (u instanceof FatSeqUpdate) {
    FatSeqUpdate fatSeqUpdate=(FatSeqUpdate)u;
    processor.applyRelated(fatSeqUpdate.getUsers(),fatSeqUpdate.getGroups(),false);
  }
  processor.processUpdate(update);
  if (u instanceof FatSeqUpdate) {
    FatSeqUpdate fatSeqUpdate=(FatSeqUpdate)u;
    processor.applyRelated(fatSeqUpdate.getUsers(),fatSeqUpdate.getGroups(),true);
  }
  this.seq=seq;
  this.state=state;
  preferences().putInt(KEY_SEQ,seq);
  preferences().putBytes(KEY_STATE,state);
  checkRunnables();
  checkFuture();
  isTimerStarted=false;
  self().sendOnce(new ForceInvalidate(),24 * 60 * 60* 1000L);
}
