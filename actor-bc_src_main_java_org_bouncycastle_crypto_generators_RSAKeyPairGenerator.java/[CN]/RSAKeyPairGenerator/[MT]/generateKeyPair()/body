{
  BigInteger p, q, n, d, e, pSub1, qSub1, phi;
  int strength=param.getStrength();
  int qBitlength=strength >>> 1;
  int pBitlength=strength - qBitlength;
  int mindiffbits=strength / 3;
  int minWeight=strength >>> 2;
  e=param.getPublicExponent();
  p=chooseRandomPrime(pBitlength,e);
  for (; ; ) {
    q=chooseRandomPrime(qBitlength,e);
    BigInteger diff=q.subtract(p).abs();
    if (diff.bitLength() < mindiffbits) {
      continue;
    }
    n=p.multiply(q);
    if (n.bitLength() != strength) {
      p=p.max(q);
      continue;
    }
    if (WNafUtil.getNafWeight(n) < minWeight) {
      p=chooseRandomPrime(pBitlength,e);
      continue;
    }
    break;
  }
  if (p.compareTo(q) < 0) {
    phi=p;
    p=q;
    q=phi;
  }
  pSub1=p.subtract(ONE);
  qSub1=q.subtract(ONE);
  phi=pSub1.multiply(qSub1);
  d=e.modInverse(phi);
  BigInteger dP, dQ, qInv;
  dP=d.remainder(pSub1);
  dQ=d.remainder(qSub1);
  qInv=q.modInverse(p);
  return new AsymmetricCipherKeyPair(new RSAKeyParameters(false,n,e),new RSAPrivateCrtKeyParameters(n,e,d,p,q,dP,dQ,qInv));
}
