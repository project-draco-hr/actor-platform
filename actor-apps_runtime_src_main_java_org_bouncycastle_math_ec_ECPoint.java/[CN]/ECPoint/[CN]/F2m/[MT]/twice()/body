{
  if (this.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  if (X1.isZero()) {
    return curve.getInfinity();
  }
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement Y1=this.y;
      ECFieldElement L1=Y1.divide(X1).add(X1);
      ECFieldElement X3=L1.square().add(L1).add(curve.getA());
      ECFieldElement Y3=X1.squarePlusProduct(X3,L1.addOne());
      return new ECPoint.F2m(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Y1=this.y, Z1=this.zs[0];
    boolean Z1IsOne=Z1.isOne();
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    ECFieldElement Y1Z1=Z1IsOne ? Y1 : Y1.multiply(Z1);
    ECFieldElement X1Sq=X1.square();
    ECFieldElement S=X1Sq.add(Y1Z1);
    ECFieldElement V=X1Z1;
    ECFieldElement vSquared=V.square();
    ECFieldElement sv=S.add(V);
    ECFieldElement h=sv.multiplyPlusProduct(S,vSquared,curve.getA());
    ECFieldElement X3=V.multiply(h);
    ECFieldElement Y3=X1Sq.square().multiplyPlusProduct(V,h,sv);
    ECFieldElement Z3=V.multiply(vSquared);
    return new ECPoint.F2m(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
  ECFieldElement L1=this.y, Z1=this.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement L1Z1=Z1IsOne ? L1 : L1.multiply(Z1);
  ECFieldElement Z1Sq=Z1IsOne ? Z1 : Z1.square();
  ECFieldElement a=curve.getA();
  ECFieldElement aZ1Sq=Z1IsOne ? a : a.multiply(Z1Sq);
  ECFieldElement T=L1.square().add(L1Z1).add(aZ1Sq);
  if (T.isZero()) {
    return new ECPoint.F2m(curve,T,curve.getB().sqrt(),withCompression);
  }
  ECFieldElement X3=T.square();
  ECFieldElement Z3=Z1IsOne ? T : T.multiply(Z1Sq);
  ECFieldElement b=curve.getB();
  ECFieldElement L3;
  if (b.bitLength() < (curve.getFieldSize() >> 1)) {
    ECFieldElement t1=L1.add(X1).square();
    ECFieldElement t2;
    if (b.isOne()) {
      t2=aZ1Sq.add(Z1Sq).square();
    }
 else {
      t2=aZ1Sq.squarePlusProduct(b,Z1Sq.square());
    }
    L3=t1.add(T).add(Z1Sq).multiply(t1).add(t2).add(X3);
    if (a.isZero()) {
      L3=L3.add(Z3);
    }
 else     if (!a.isOne()) {
      L3=L3.add(a.addOne().multiply(Z3));
    }
  }
 else {
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    L3=X1Z1.squarePlusProduct(T,L1Z1).add(X3).add(Z3);
  }
  return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}
default :
{
throw new IllegalStateException("unsupported coordinate system");
}
}
}
