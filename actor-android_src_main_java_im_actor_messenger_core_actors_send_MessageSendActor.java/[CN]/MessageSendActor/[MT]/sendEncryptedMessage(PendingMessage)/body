{
  final int uid;
  if (message.getConvType() == DialogType.TYPE_USER) {
    uid=message.getConvId();
  }
 else {
    return;
  }
  long keysStart=System.currentTimeMillis();
  UserModel receiver=users().get(uid);
  UserModel me=users().get(myUid());
  if (receiver == null || me == null) {
    pending.remove(message.getRid());
    return;
  }
  java.security.PublicKey pk=keyStorage().getKeyPair().getPublic();
  long myKey=CryptoUtils.keyHash(pk);
  PublicKeysStorage.KeyLoadResult myKeys=PublicKeysStorage.getUserPublicKeys(me.getRaw(),myKey);
  PublicKeysStorage.KeyLoadResult userKeys=PublicKeysStorage.getUserPublicKeys(receiver.getRaw(),0);
  if (myKeys.getMissing().size() > 0 || userKeys.getMissing().size() > 0) {
    Logger.d(TAG,"We need some keys, loading " + (myKeys.getMissing().size() + userKeys.getMissing().size()) + " required keys");
    List<AskFuture> list=new ArrayList<AskFuture>();
    for (    Long m : myKeys.getMissing()) {
      list.add(ask(KeyLoaderActor.loader(me.getId(),me.getAccessHash(),m)));
    }
    for (    Long m : userKeys.getMissing()) {
      list.add(ask(KeyLoaderActor.loader(receiver.getId(),receiver.getAccessHash(),m)));
    }
    combine(new AskCallback<Object[]>(){
      @Override public void onResult(      Object[] result){
        Log.d(TAG,"Sending message after key loading");
        sendEncryptedMessage(message);
      }
      @Override public void onError(      Throwable throwable){
        Log.d(TAG,"Key load error" + throwable);
      }
    }
,list.toArray(new AskFuture[0]));
    return;
  }
  Logger.d(TAG,"Loading keys in " + (System.currentTimeMillis() - keysStart) + " ms");
  long aesStart=System.currentTimeMillis();
  byte[] aesKey=CryptoUtils.generateSeed(32);
  byte[] aesIv=CryptoUtils.generateSeed(16);
  byte[] key=CryptoUtils.concat(aesKey,aesIv);
  byte[] plainMessage=CryptoUtils.concat(intToBytes(message.getMessageContent().length),message.getMessageContent());
  final byte[] encrypted=AESEncryptionUtils.encrypt(plainMessage,aesKey,aesIv);
  Logger.d(TAG,"AES in " + (System.currentTimeMillis() - aesStart) + " ms");
  ask(RsaActor.encryptor().encrypt(key,myKeys.getKeys().toArray(new PublicKey[0]),userKeys.getKeys().toArray(new PublicKey[0])),new FutureCallback<RsaResult>(){
    @Override public void onResult(    RsaResult result){
      Log.d(TAG,"Successfuly encrypted");
      List<EncryptedAesKey> ownKeys=new ArrayList<EncryptedAesKey>();
      List<EncryptedAesKey> keys=new ArrayList<EncryptedAesKey>();
      for (      RsaResult.RsaPart my : result.getMyParts()) {
        ownKeys.add(new EncryptedAesKey(my.getKeyHash(),my.getEncryptedData()));
      }
      for (      RsaResult.RsaPart my : result.getForeignParts()) {
        keys.add(new EncryptedAesKey(my.getKeyHash(),my.getEncryptedData()));
      }
      sendEncryptedMessage(message,keys,ownKeys,encrypted);
    }
    @Override public void onError(    Throwable throwable){
      Log.d(TAG,"Error #" + message.getRid() + " error "+ throwable);
      pending.remove(message.getRid());
      ConversationActor.conv(0,uid).onMessageError(message.getRid());
    }
  }
);
}
