{
  final long randomId=message.getRid();
  final int chatType;
  final int chatId;
  final OutPeer outPeer;
  final Peer peer;
  if (message.getConvType() == DialogType.TYPE_USER) {
    chatType=DialogType.TYPE_USER;
    chatId=message.getConvId();
    UserModel receiver=users().get(chatId);
    if (receiver == null) {
      pending.remove(message.getRid());
      return;
    }
    outPeer=new OutPeer(PeerType.PRIVATE,chatId,receiver.getAccessHash());
    peer=new Peer(PeerType.PRIVATE,chatId);
  }
 else   if (message.getConvType() == DialogType.TYPE_GROUP) {
    chatType=DialogType.TYPE_GROUP;
    chatId=message.getConvId();
    GroupModel group=groups().get(chatId);
    if (group == null) {
      pending.remove(message.getRid());
      return;
    }
    outPeer=new OutPeer(PeerType.GROUP,chatId,group.getAccessHash());
    peer=new Peer(PeerType.GROUP,chatId);
  }
 else {
    return;
  }
  ask(requests().sendMessage(outPeer,randomId,new MessageContent(message.getMessageType(),message.getMessageContent())),new FutureCallback<ResponseSeqDate>(){
    @Override public void onResult(    ResponseSeqDate result){
      Log.d(TAG,"Sent #" + randomId);
      pending.remove(randomId);
      ConversationActor.conv(chatType,chatId).onMessageSent(randomId,result.getDate());
      system().actorOf(SequenceActor.sequence()).send(new SequenceActor.SeqUpdate(result.getSeq(),result.getState(),new UpdateMessageSent(peer,randomId,result.getDate())));
    }
    @Override public void onError(    Throwable throwable){
      pending.remove(randomId);
      ConversationActor.conv(chatType,chatId).onMessageError(randomId);
    }
  }
);
}
