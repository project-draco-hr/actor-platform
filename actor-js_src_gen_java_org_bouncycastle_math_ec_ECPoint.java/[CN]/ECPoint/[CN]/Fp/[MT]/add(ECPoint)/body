{
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return this;
  }
  if (this == b) {
    return twice();
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
  ECFieldElement X1=this.x, Y1=this.y;
  ECFieldElement X2=b.x, Y2=b.y;
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement dx=X2.subtract(X1), dy=Y2.subtract(Y1);
      if (dx.isZero()) {
        if (dy.isZero()) {
          return twice();
        }
        return curve.getInfinity();
      }
      ECFieldElement gamma=dy.divide(dx);
      ECFieldElement X3=gamma.square().subtract(X1).subtract(X2);
      ECFieldElement Y3=gamma.multiply(X1.subtract(X3)).subtract(Y1);
      return new ECPoint.Fp(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Z1=this.zs[0];
    ECFieldElement Z2=b.zs[0];
    boolean Z1IsOne=Z1.isOne();
    boolean Z2IsOne=Z2.isOne();
    ECFieldElement u1=Z1IsOne ? Y2 : Y2.multiply(Z1);
    ECFieldElement u2=Z2IsOne ? Y1 : Y1.multiply(Z2);
    ECFieldElement u=u1.subtract(u2);
    ECFieldElement v1=Z1IsOne ? X2 : X2.multiply(Z1);
    ECFieldElement v2=Z2IsOne ? X1 : X1.multiply(Z2);
    ECFieldElement v=v1.subtract(v2);
    if (v.isZero()) {
      if (u.isZero()) {
        return this.twice();
      }
      return curve.getInfinity();
    }
    ECFieldElement w=Z1IsOne ? Z2 : Z2IsOne ? Z1 : Z1.multiply(Z2);
    ECFieldElement vSquared=v.square();
    ECFieldElement vCubed=vSquared.multiply(v);
    ECFieldElement vSquaredV2=vSquared.multiply(v2);
    ECFieldElement A=u.square().multiply(w).subtract(vCubed).subtract(two(vSquaredV2));
    ECFieldElement X3=v.multiply(A);
    ECFieldElement Y3=vSquaredV2.subtract(A).multiplyMinusProduct(u,u2,vCubed);
    ECFieldElement Z3=vCubed.multiply(w);
    return new ECPoint.Fp(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_JACOBIAN:
case ECCurve.COORD_JACOBIAN_MODIFIED:
{
  ECFieldElement Z1=this.zs[0];
  ECFieldElement Z2=b.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement X3, Y3, Z3, Z3Squared=null;
  if (!Z1IsOne && Z1.equals(Z2)) {
    ECFieldElement dx=X1.subtract(X2), dy=Y1.subtract(Y2);
    if (dx.isZero()) {
      if (dy.isZero()) {
        return twice();
      }
      return curve.getInfinity();
    }
    ECFieldElement C=dx.square();
    ECFieldElement W1=X1.multiply(C), W2=X2.multiply(C);
    ECFieldElement A1=W1.subtract(W2).multiply(Y1);
    X3=dy.square().subtract(W1).subtract(W2);
    Y3=W1.subtract(X3).multiply(dy).subtract(A1);
    Z3=dx;
    if (Z1IsOne) {
      Z3Squared=C;
    }
 else {
      Z3=Z3.multiply(Z1);
    }
  }
 else {
    ECFieldElement Z1Squared, U2, S2;
    if (Z1IsOne) {
      Z1Squared=Z1;
      U2=X2;
      S2=Y2;
    }
 else {
      Z1Squared=Z1.square();
      U2=Z1Squared.multiply(X2);
      ECFieldElement Z1Cubed=Z1Squared.multiply(Z1);
      S2=Z1Cubed.multiply(Y2);
    }
    boolean Z2IsOne=Z2.isOne();
    ECFieldElement Z2Squared, U1, S1;
    if (Z2IsOne) {
      Z2Squared=Z2;
      U1=X1;
      S1=Y1;
    }
 else {
      Z2Squared=Z2.square();
      U1=Z2Squared.multiply(X1);
      ECFieldElement Z2Cubed=Z2Squared.multiply(Z2);
      S1=Z2Cubed.multiply(Y1);
    }
    ECFieldElement H=U1.subtract(U2);
    ECFieldElement R=S1.subtract(S2);
    if (H.isZero()) {
      if (R.isZero()) {
        return this.twice();
      }
      return curve.getInfinity();
    }
    ECFieldElement HSquared=H.square();
    ECFieldElement G=HSquared.multiply(H);
    ECFieldElement V=HSquared.multiply(U1);
    X3=R.square().add(G).subtract(two(V));
    Y3=V.subtract(X3).multiplyMinusProduct(R,G,S1);
    Z3=H;
    if (!Z1IsOne) {
      Z3=Z3.multiply(Z1);
    }
    if (!Z2IsOne) {
      Z3=Z3.multiply(Z2);
    }
    if (Z3 == H) {
      Z3Squared=HSquared;
    }
  }
  ECFieldElement[] zs;
  if (coord == ECCurve.COORD_JACOBIAN_MODIFIED) {
    ECFieldElement W3=calculateJacobianModifiedW(Z3,Z3Squared);
    zs=new ECFieldElement[]{Z3,W3};
  }
 else {
    zs=new ECFieldElement[]{Z3};
  }
  return new ECPoint.Fp(curve,X3,Y3,zs,this.withCompression);
}
default :
{
throw new IllegalStateException("unsupported coordinate system");
}
}
}
