{
  Log.d(TAG,"preStart");
  isReady=false;
  WebRTCIceServer[] iceServers=config().getWebRTCIceServers();
  WebRTCSettings settings=new WebRTCSettings(false,false);
  Promises.tuple(WebRTC.createPeerConnection(iceServers,settings),WebRTC.getUserAudio()).map(new FunctionTupled2<WebRTCPeerConnection,WebRTCMediaStream,WebRTCPeerConnection>(){
    @Override public WebRTCPeerConnection apply(    WebRTCPeerConnection webRTCPeerConnection,    WebRTCMediaStream stream){
      setEnabled(stream);
      PeerConnectionActor.this.stream=stream;
      webRTCPeerConnection.addOwnStream(stream);
      return webRTCPeerConnection;
    }
  }
).then(new Consumer<WebRTCPeerConnection>(){
    @Override public void apply(    WebRTCPeerConnection webRTCPeerConnection){
      Log.d(TAG,"preStart:then");
      PeerConnectionActor.this.peerConnection=webRTCPeerConnection;
      PeerConnectionActor.this.peerConnection.addCallback(new WebRTCPeerConnectionCallback(){
        @Override public void onCandidate(        int label,        String id,        String candidate){
          root.send(new DoCandidate(uid,deviceId,label,id,candidate));
        }
        @Override public void onStreamAdded(        WebRTCMediaStream stream){
          if (isSilentMode && isSilented) {
            stream.setEnabled(false);
            silencedStreams.add(stream);
          }
          root.send(new OnStreamAdded(uid,deviceId,stream));
        }
        @Override public void onStreamRemoved(        WebRTCMediaStream stream){
          silencedStreams.remove(stream);
          root.send(new OnStreamRemoved(uid,deviceId,stream));
        }
        @Override public void onRenegotiationNeeded(){
        }
      }
);
      state=State.WAITING_HANDSHAKE;
      isReady=true;
      unstashAll();
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
      Log.d(TAG,"preStart:error");
      e.printStackTrace();
      onHandshakeFailure();
    }
  }
).done(self());
}
