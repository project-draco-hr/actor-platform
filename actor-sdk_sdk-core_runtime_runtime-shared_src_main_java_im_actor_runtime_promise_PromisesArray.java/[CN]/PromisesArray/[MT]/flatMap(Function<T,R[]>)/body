{
  return new PromisesArray<R>(new Promise<Promise<R>[]>(){
    @Override void exec(    final PromiseResolver resolver){
      promises.then(new Consumer<Promise<T>[]>(){
        @Override public void apply(        final Promise<T>[] sourcePromises){
          final Object[][] res=new Object[sourcePromises.length][];
          final Boolean[] ended=new Boolean[sourcePromises.length];
          for (int i=0; i < sourcePromises.length; i++) {
            final int finalI=i;
            sourcePromises[i].then(new Consumer<T>(){
              @Override public void apply(              T t){
                res[finalI]=map.apply(t);
                ended[finalI]=true;
                for (int i1=0; i1 < sourcePromises.length; i1++) {
                  if (ended[i1] == null || !ended[i1]) {
                    return;
                  }
                }
                ArrayList<Promise<R>> resultList=new ArrayList<>();
                for (int i2=0; i2 < sourcePromises.length; i2++) {
                  for (int j=0; j < res[i2].length; j++) {
                    resultList.add(Promises.success((R)res[i2][j]));
                  }
                }
                resolver.result(resultList.toArray(new Promise[0]));
              }
            }
);
            sourcePromises[i].failure(new Consumer<Exception>(){
              @Override public void apply(              Exception e){
                resolver.error(e);
              }
            }
);
            sourcePromises[i].done(resolver.getDispatcher());
          }
          if (sourcePromises.length == 0) {
            resolver.result(new Promise[0]);
          }
        }
      }
);
      promises.failure(new Consumer<Exception>(){
        @Override public void apply(        Exception e){
          resolver.error(e);
        }
      }
);
      promises.done(resolver.getDispatcher());
    }
  }
);
}
