{
  AppContext.setContext(application);
  Formatter.init(application);
  system().setClassLoader(AppContext.getContext().getClassLoader());
  AndroidTrace.initTrace(system(),new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread thread,    Throwable ex){
      if (BuildConfig.REPORT_CRASHES) {
      }
    }
  }
);
  system().addDispatcher("ui",new UiActorDispatcher("ui",system()));
  system().addDispatcher("db",1);
  system().addDispatcher("contacts",1);
  system().addDispatcher("file_encryption",1);
  system().addDispatcher("rsa",1);
  system().addDispatcher("updates",1);
  system().addDispatcher("push",1);
  this.emojiProcessor=new EmojiProcessor(application);
  ActivityManager activityManager=(ActivityManager)AppContext.getContext().getSystemService(Context.ACTIVITY_SERVICE);
  int memoryInMB=Math.min(activityManager.getMemoryClass(),32);
  long totalAppHeap=memoryInMB * 1024 * 1024;
  int cacheLimit=(int)totalAppHeap / 4;
  int freeCacheLimit=cacheLimit / 2;
  BitmapClasificator clasificator=new BitmapClasificator.Builder().startExactSize(100,100).setFreeSize(2).setLruSize(15).endFilter().startAny().useSizeInBytes().setLruSize(cacheLimit).setFreeSize(freeCacheLimit).endFilter().build();
  this.imageLoader=new ImageLoader(clasificator,application);
  this.imageLoader.getTaskResolver().register(ImagePreviewTask.class,ImagePreviewActor.class);
  this.imageLoader.getTaskResolver().register(VideoPreviewTask.class,VideoPreviewActor.class);
  this.imageLoader.getTaskResolver().register(VideoTask.class,VideoActor.class);
  this.imageLoader.getTaskResolver().register(AvatarTask.class,AvatarActor.class);
  this.imageLoader.getTaskResolver().register(FullAvatarTask.class,FullAvatarActor.class);
  JavaInit.init();
  im.actor.model.Configuration configuration=new im.actor.model.Configuration();
  configuration.setMainThread(new MainThread(){
    private Handler handler=new Handler(Looper.getMainLooper());
    @Override public void runOnUiThread(    Runnable runnable){
      handler.post(runnable);
    }
  }
);
  PropertiesProvider propertiesProvider=new PropertiesProvider();
  configuration.setOnlineCallback(new OnlineCallback(){
    @Override public void onUserOnline(    int uid){
      users().get(uid).getPresence().change(new UserPresence(UserPresence.State.ONLINE,0));
    }
    @Override public void onUserOffline(    int uid){
      users().get(uid).getPresence().change(new UserPresence(UserPresence.State.OFFLINE,0));
    }
    @Override public void onUserLastSeen(    int uid,    long lastSeen){
      users().get(uid).getPresence().change(new UserPresence(UserPresence.State.OFFLINE,lastSeen));
    }
    @Override public void onGroupOnline(    int gid,    int count){
    }
  }
);
  configuration.setTypingCallback(new TypingCallback(){
    @Override public void onTypingStart(    int uid){
      TypingModel.privateChatTyping(uid).change(true);
    }
    @Override public void onTypingEnd(    int uid){
      TypingModel.privateChatTyping(uid).change(false);
    }
    @Override public void onGroupTyping(    int gid,    int[] uids){
      TypingModel.groupChatTyping(gid).change(uids);
    }
  }
);
  configuration.setEnginesFactory(new AppEngineFactory());
  configuration.setPreferencesStorage(propertiesProvider);
  configuration.setEndpoints(new Endpoints(new ConnectionEndpoint[]{new ConnectionEndpoint(BuildConfig.API_HOST,BuildConfig.API_PORT,BuildConfig.API_SSL ? ConnectionEndpoint.Type.TCP_TLS : ConnectionEndpoint.Type.TCP)}));
  this.messenger=new im.actor.model.Messenger(configuration);
}
