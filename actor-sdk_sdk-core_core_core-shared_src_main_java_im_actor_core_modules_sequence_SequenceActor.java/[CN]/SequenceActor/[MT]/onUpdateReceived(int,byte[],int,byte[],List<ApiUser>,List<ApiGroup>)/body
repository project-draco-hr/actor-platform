{
  if (seq <= this.seq) {
    Log.d(TAG,"Ignored SeqUpdate {seq:" + seq + ", currentSeq: "+ this.seq+ "}");
    return;
  }
  Log.d(TAG,"SeqUpdate {seq:" + seq + "}");
  if (!isValidated) {
    Log.d(TAG,"Stashing update");
    stash();
    return;
  }
  if (seq != this.seq + 1) {
    stash();
    if (seq - this.seq > INVALIDATE_MAX_SEC_HOLE) {
      Log.w(TAG,"Out of sequence: Too big hole. Force invalidate immediately");
      forceInvalidate();
    }
    if (isTimerStarted) {
      Log.w(TAG,"Out of sequence: timer already started");
    }
 else {
      Log.w(TAG,"Out of sequence: starting timer for invalidation");
      startInvalidationTimer();
    }
    return;
  }
  Log.d(TAG,"Handling update #" + seq);
  startWakeLock();
  handler.onSeqUpdate(type,body,users,groups).then(new Consumer<SequenceHandlerActor.UpdateProcessed>(){
    @Override public void apply(    SequenceHandlerActor.UpdateProcessed updateProcessed){
      Log.d(TAG,"Handling update ended #" + seq);
      onUpdatesApplied(seq,state);
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
      SequenceActor.this.seq=finishedSeq;
      SequenceActor.this.state=finishedState;
      invalidate();
    }
  }
).done(self());
  this.seq=seq;
  this.state=state;
  unstashAll();
  stopInvalidationTimer();
}
