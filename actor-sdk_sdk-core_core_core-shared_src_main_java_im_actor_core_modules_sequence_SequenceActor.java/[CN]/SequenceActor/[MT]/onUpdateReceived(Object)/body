{
  final int seq;
  final byte[] state;
  int type;
  byte[] body;
  if (u instanceof SeqUpdate) {
    seq=((SeqUpdate)u).getSeq();
    state=((SeqUpdate)u).getState();
    type=((SeqUpdate)u).getUpdateHeader();
    body=((SeqUpdate)u).getUpdate();
  }
 else   if (u instanceof FatSeqUpdate) {
    seq=((FatSeqUpdate)u).getSeq();
    state=((FatSeqUpdate)u).getState();
    type=((FatSeqUpdate)u).getUpdateHeader();
    body=((FatSeqUpdate)u).getUpdate();
  }
 else {
    throw new RuntimeException();
  }
  if (seq <= this.seq) {
    Log.d(TAG,"Ignored SeqUpdate {seq:" + seq + ", currentSeq: "+ this.seq+ "}");
    return;
  }
  Log.d(TAG,"SeqUpdate {seq:" + seq + "}");
  if (!isValidated) {
    Log.d(TAG,"Caching in further map");
    further.put(seq,u);
    return;
  }
  if (seq != this.seq + 1) {
    further.put(seq,u);
    if (seq - this.seq > INVALIDATE_MAX_SEC_HOLE) {
      Log.w(TAG,"Out of sequence: Too big hole. Force invalidate immediately");
      self().sendOnce(new ForceInvalidate());
      return;
    }
    if (isTimerStarted) {
      Log.w(TAG,"Out of sequence: timer already started");
    }
 else {
      Log.w(TAG,"Out of sequence: starting timer for invalidation");
      self().sendOnce(new ForceInvalidate(),INVALIDATE_GAP);
      isTimerStarted=true;
    }
    return;
  }
  List<ApiUser> users=null;
  List<ApiGroup> groups=null;
  if (u instanceof FatSeqUpdate) {
    users=((FatSeqUpdate)u).getUsers();
    groups=((FatSeqUpdate)u).getGroups();
  }
  Log.d(TAG,"Handling update #" + seq);
  handler.onSeqUpdate(type,body,users,groups).then(new Consumer<SequenceHandlerActor.UpdateProcessed>(){
    @Override public void apply(    SequenceHandlerActor.UpdateProcessed updateProcessed){
      onUpdatesApplied(seq,state);
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
    }
  }
).done(self());
  this.seq=seq;
  this.state=state;
  checkFuture();
  isTimerStarted=false;
  self().sendOnce(new ForceInvalidate(),24 * 60 * 60* 1000L);
}
