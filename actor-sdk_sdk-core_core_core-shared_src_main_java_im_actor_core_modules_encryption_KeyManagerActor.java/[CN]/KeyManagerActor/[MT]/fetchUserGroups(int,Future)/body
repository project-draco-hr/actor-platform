{
  Log.d(TAG,"fetchUserGroups");
  UserKeys userKeys=cachedUserKeys.get(uid);
  if (userKeys == null) {
    byte[] cached=encryptionKeysStorage.loadItem(uid);
    if (cached != null) {
      try {
        userKeys=new UserKeys(cached);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  if (userKeys != null) {
    Log.d(TAG,"onResult:fast");
    future.onResult(new FetchUserKeyGroupsResponse(userKeys));
    return;
  }
  Log.d(TAG,"Requesting");
  User user=users().getValue(uid);
  request(new RequestLoadPublicKeyGroups(new ApiUserOutPeer(uid,user.getAccessHash())),new RpcCallback<ResponsePublicKeyGroups>(){
    @Override public void onResult(    ResponsePublicKeyGroups response){
      Log.d(TAG,"onResult");
      UserKeysGroup[] groups=new UserKeysGroup[response.getPublicKeyGroups().size()];
      for (int i=0; i < groups.length; i++) {
        ApiEncryptionKeyGroup encryptionKey=response.getPublicKeyGroups().get(i);
        UserPublicKey identity=new UserPublicKey(encryptionKey.getIdentityKey().getKeyId(),encryptionKey.getIdentityKey().getKeyAlg(),encryptionKey.getIdentityKey().getKeyMaterial());
        UserPublicKey[] keys=new UserPublicKey[encryptionKey.getKeys().size()];
        for (int j=0; j < keys.length; j++) {
          keys[j]=new UserPublicKey(encryptionKey.getKeys().get(j).getKeyId(),encryptionKey.getKeys().get(j).getKeyAlg(),encryptionKey.getKeys().get(j).getKeyMaterial());
        }
        groups[i]=new UserKeysGroup(encryptionKey.getKeyGroupId(),identity,keys,new UserPublicKey[0]);
      }
      UserKeys userKeys1=new UserKeys(uid,groups);
      encryptionKeysStorage.addOrUpdateItem(uid,userKeys1.toByteArray());
      future.onResult(new FetchUserKeyGroupsResponse(userKeys1));
    }
    @Override public void onError(    RpcException e){
      Log.d(TAG,"onError");
      future.onError(e);
    }
  }
);
}
