{
  Log.d(TAG,"fetchUserGroups");
  final UserKeys userKeys=getCachedUserKeys(uid);
  if (userKeys != null) {
    Log.d(TAG,"fetchUserGroups:cached");
    future.onResult(new FetchUserKeyGroupsResponse(userKeys));
    return;
  }
  Log.d(TAG,"fetchUserGroups:loading");
  User user=users().getValue(uid);
  request(new RequestLoadPublicKeyGroups(new ApiUserOutPeer(uid,user.getAccessHash())),new RpcCallback<ResponsePublicKeyGroups>(){
    @Override public void onResult(    ResponsePublicKeyGroups response){
      ArrayList<UserKeysGroup> keysGroups=new ArrayList<UserKeysGroup>();
      for (      ApiEncryptionKeyGroup keyGroup : response.getPublicKeyGroups()) {
        UserKeysGroup validatedKeysGroup=validateUserKeysGroup(uid,keyGroup);
        if (validatedKeysGroup != null) {
          keysGroups.add(validatedKeysGroup);
        }
      }
      if (keysGroups.size() != 0) {
        UserKeys userKeys1=new UserKeys(uid,keysGroups.toArray(new UserKeysGroup[keysGroups.size()]));
        cacheUserKeys(userKeys1);
        future.onResult(new FetchUserKeyGroupsResponse(userKeys1));
      }
 else {
        Log.w(TAG,"(uid:" + uid + ") No valid key groups found");
        future.onError(new RuntimeException("No key groups found"));
      }
    }
    @Override public void onError(    RpcException e){
      future.onError(e);
    }
  }
);
}
