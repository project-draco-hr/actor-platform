{
  final UserKeys keys=getCachedUserKeys(uid);
  UserKeysGroup keysGroup=null;
  for (  UserKeysGroup g : keys.getUserKeysGroups()) {
    Log.d(TAG,"KeyGroup (uid: " + uid + "): "+ g.getKeyGroupId());
    if (g.getKeyGroupId() == keyGroupId) {
      keysGroup=g;
    }
  }
  if (keysGroup == null) {
    future.error(new RuntimeException("Key Group #" + keyGroupId + " not found"));
    return;
  }
  for (  PublicKey p : keysGroup.getEphemeralKeys()) {
    if (p.getKeyId() == keyId) {
      future.result(new FetchUserEphemeralKeyResponse(p));
      return;
    }
  }
  ArrayList<Long> ids=new ArrayList<Long>();
  ids.add(keyId);
  final UserKeysGroup finalKeysGroup=keysGroup;
  request(new RequestLoadPublicKey(new ApiUserOutPeer(uid,getUser(uid).getAccessHash()),keyGroupId,ids),new RpcCallback<ResponsePublicKeys>(){
    @Override public void onResult(    ResponsePublicKeys response){
      if (response.getPublicKey().size() == 0) {
        Log.w(TAG,"Public key error");
        future.error(new RuntimeException());
        return;
      }
      ApiEncryptionKey key=response.getPublicKey().get(0);
      PublicKey pkey=new PublicKey(keyId,key.getKeyAlg(),key.getKeyMaterial());
      UserKeysGroup userKeysGroup=finalKeysGroup.addPublicKey(pkey);
      cacheUserKeys(keys.removeUserKeyGroup(userKeysGroup.getKeyGroupId()).addUserKeyGroup(userKeysGroup));
      Log.d(TAG,"(uid: " + uid + ") Fetched PreKey "+ Crypto.keyHash(key.getKeyMaterial()));
      future.result(new FetchUserEphemeralKeyResponse(pkey));
    }
    @Override public void onError(    RpcException e){
      Log.w(TAG,"Public key error");
      Log.e(TAG,e);
      future.error(e);
    }
  }
);
}
