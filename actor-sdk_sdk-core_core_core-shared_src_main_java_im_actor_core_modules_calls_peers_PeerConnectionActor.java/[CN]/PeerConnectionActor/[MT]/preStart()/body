{
  isReady=false;
  WebRTCIceServer[] rtcIceServers=ManagedList.of(iceServers).map(new Function<ApiICEServer,WebRTCIceServer>(){
    @Override public WebRTCIceServer apply(    ApiICEServer apiICEServer){
      return new WebRTCIceServer(apiICEServer.getUrl(),apiICEServer.getUsername(),apiICEServer.getCredential());
    }
  }
).toArray(new WebRTCIceServer[0]);
  WebRTCSettings settings=new WebRTCSettings(false,false);
  WebRTC.createPeerConnection(rtcIceServers,settings).then(new Consumer<WebRTCPeerConnection>(){
    @Override public void apply(    WebRTCPeerConnection webRTCPeerConnection){
      PeerConnectionActor.this.peerConnection=webRTCPeerConnection;
      PeerConnectionActor.this.peerConnection.addOwnStream(stream);
      PeerConnectionActor.this.peerConnection.addCallback(new WebRTCPeerConnectionCallback(){
        @Override public void onCandidate(        int label,        String id,        String candidate){
          callback.onCandidate(label,id,candidate);
        }
        @Override public void onStreamAdded(        WebRTCMediaStream stream){
          stream.setEnabled(false);
          callback.onStreamAdded(stream);
        }
        @Override public void onStreamRemoved(        WebRTCMediaStream stream){
          callback.onStreamRemoved(stream);
        }
        @Override public void onRenegotiationNeeded(){
        }
      }
);
      state=PeerConnectionState.WAITING_HANDSHAKE;
      onReady();
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
      Log.d(TAG,"preStart:error");
      e.printStackTrace();
      onHandshakeFailure();
    }
  }
).done(self());
}
