{
  if (promises.length == 0) {
    throw new RuntimeException("Promises array must not be empty");
  }
  return new Promise<T[]>(){
    @Override protected void exec(    @NotNull final PromiseResolver<T[]> executor){
      final T[] res=(T[])new Object[promises.length];
      final boolean[] isSet=new boolean[promises.length];
      final Promise self=this;
      for (int i=0; i < res.length; i++) {
        final int finalI=i;
        promises[i].then(new Supplier<T>(){
          @Override public void apply(          T t){
            if (self.isFinished()) {
              return;
            }
            res[finalI]=t;
            isSet[finalI]=true;
            for (int i=0; i < promises.length; i++) {
              if (!isSet[i]) {
                return;
              }
            }
            executor.result(res);
          }
        }
).failure(new Supplier<Exception>(){
          @Override public void apply(          Exception e){
            if (self.isFinished()) {
              return;
            }
            executor.error(e);
          }
        }
);
      }
      for (      Promise<T> p : promises) {
        p.done(self.getDispatchActor());
      }
    }
  }
;
}
