{
  this.binded=data.getPeer().getUnuqueId();
  this.bindedItem=data;
  avatar.bind(data);
  if (data.getUnreadCount() > 0) {
    counter.setText(Integer.toString(data.getUnreadCount()));
    counter.setVisibility(View.VISIBLE);
  }
 else {
    counter.setVisibility(View.GONE);
  }
  title.setText(data.getDialogTitle());
  Drawable left=null;
  if (data.getPeer().getPeerType() == PeerType.GROUP) {
    left=new TintDrawable(context.getResources().getDrawable(R.drawable.dialogs_group),ActorSDK.sharedActor().style.getDialogsTitleColor());
  }
  title.setCompoundDrawablesWithIntrinsicBounds(left,null,null,null);
  if (data.getDate() > 0) {
    time.setVisibility(View.VISIBLE);
    time.setText(messenger().getFormatter().formatShortDate(data.getDate()));
  }
 else {
    time.setVisibility(View.GONE);
  }
  bindedText=messenger().getFormatter().formatDialogText(data);
  if (SmileProcessor.containsEmoji(bindedText)) {
    if (emoji().isLoaded()) {
      bindedText=emoji().processEmojiCompatMutable(bindedText,SmileProcessor.CONFIGURATION_BUBBLES);
    }
 else {
      emoji().registerListener(new SmilesListener(){
        @Override public void onSmilesUpdated(        boolean completed){
          CharSequence emojiProcessed=emoji().processEmojiCompatMutable(bindedText,SmileProcessor.CONFIGURATION_DIALOGS);
          if (text.getText().equals(bindedText)) {
            text.setText(emojiProcessed);
          }
          bindedText=emojiProcessed;
        }
      }
);
    }
  }
  if (privateTypingListener != null) {
    messenger().getTyping(bindedUid).unsubscribe(privateTypingListener);
    privateTypingListener=null;
  }
  if (groupTypingListener != null) {
    messenger().getGroupTyping(bindedGid).unsubscribe(groupTypingListener);
    groupTypingListener=null;
  }
  final int textColor;
  if (data.getMessageType() != ContentType.TEXT) {
    textColor=style.getDialogsActiveTextColor();
  }
 else {
    textColor=style.getDialogsTextColor();
  }
  if (data.getPeer().getPeerType() == PeerType.PRIVATE) {
    bindedUid=data.getPeer().getPeerId();
    privateTypingListener=new ValueChangedListener<Boolean>(){
      @Override public void onChanged(      Boolean val,      Value<Boolean> Value){
        if (val) {
          text.setText(messenger().getFormatter().formatTyping());
          text.setTextColor(ActorSDK.sharedActor().style.getDialogsTypingColor());
        }
 else {
          text.setText(bindedText);
          text.setTextColor(textColor);
        }
      }
    }
;
    messenger().getTyping(bindedUid).subscribe(privateTypingListener);
  }
 else   if (data.getPeer().getPeerType() == PeerType.GROUP) {
    bindedGid=data.getPeer().getPeerId();
    groupTypingListener=new ValueChangedListener<int[]>(){
      @Override public void onChanged(      int[] val,      Value<int[]> Value){
        if (val.length != 0) {
          if (val.length == 1) {
            text.setText(messenger().getFormatter().formatTyping(messenger().getUsers().get(val[0]).getName().get()));
          }
 else {
            text.setText(messenger().getFormatter().formatTyping(val.length));
          }
          text.setTextColor(ActorSDK.sharedActor().style.getDialogsTypingColor());
        }
 else {
          text.setText(bindedText);
          text.setTextColor(textColor);
        }
      }
    }
;
    messenger().getGroupTyping(bindedGid).subscribe(groupTypingListener);
  }
 else {
    text.setText(bindedText);
    text.setTextColor(textColor);
  }
  if (data.getSenderId() != myUid()) {
    state.setVisibility(View.GONE);
  }
 else {
switch (data.getStatus()) {
default :
case PENDING:
      state.setResource(R.drawable.msg_clock);
    state.setTint(pendingColor);
  break;
case SENT:
state.setResource(R.drawable.msg_check_1);
state.setTint(sentColor);
break;
case RECEIVED:
state.setResource(R.drawable.msg_check_2);
state.setTint(receivedColor);
break;
case READ:
state.setResource(R.drawable.msg_check_2);
state.setTint(readColor);
break;
case ERROR:
state.setResource(R.drawable.msg_error);
state.setTint(errorColor);
break;
}
state.setVisibility(View.VISIBLE);
}
if (isLast) {
separator.setVisibility(View.GONE);
}
 else {
separator.setVisibility(View.VISIBLE);
}
}
