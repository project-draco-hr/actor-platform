{
  long parseStart=im.actor.runtime.Runtime.getCurrentTime();
  final ArrayList<Update> updates=new ArrayList<Update>();
  for (  ApiUpdateContainer u : difference.getUpdates()) {
    try {
      updates.add(updatesParser.read(u.getUpdateHeader(),u.getUpdate()));
    }
 catch (    IOException e) {
      e.printStackTrace();
      Log.d(TAG,"Broken update #" + u.getUpdateHeader() + ": ignoring");
    }
  }
  Log.d(TAG,"Difference parsed  in " + (im.actor.runtime.Runtime.getCurrentTime() - parseStart) + " ms");
  if (updates.size() > 0) {
    String command="Difference updates:";
    for (    Update u : updates) {
      command+="\n| " + u;
    }
    Log.d(TAG,command);
  }
  final ArrayList<ApiUserOutPeer> pendingUserPeers=new ArrayList<>();
  final ArrayList<ApiGroupOutPeer> pendingGroupPeers=new ArrayList<>();
  for (  ApiUserOutPeer refPeer : difference.getUsersRefs()) {
    if (getUser(refPeer.getUid()) != null) {
      continue;
    }
    pendingUserPeers.add(refPeer);
  }
  for (  ApiGroupOutPeer refPeer : difference.getGroupsRefs()) {
    if (getGroup(refPeer.getGroupId()) != null) {
      continue;
    }
    pendingGroupPeers.add(refPeer);
  }
  if (pendingGroupPeers.size() > 0 || pendingUserPeers.size() > 0) {
    Log.d(TAG,"Downloading pending peers (users: " + pendingUserPeers.size() + ", groups: "+ pendingGroupPeers.size()+ ")");
    isUpdating=true;
    return new Promise<>(new PromiseFunc<UpdateProcessed>(){
      @Override public void exec(      final PromiseResolver<UpdateProcessed> resolver){
        api(new RequestGetReferencedEntitites(pendingUserPeers,pendingGroupPeers)).then(new Consumer<ResponseGetReferencedEntitites>(){
          @Override public void apply(          ResponseGetReferencedEntitites responseGetReferencedEntitites){
            Log.d(TAG,"Pending peers downloaded");
            processor.applyRelated(responseGetReferencedEntitites.getUsers(),responseGetReferencedEntitites.getGroups(),false);
            long applyStart=im.actor.runtime.Runtime.getCurrentTime();
            processor.applyDifferenceUpdate(difference.getUsers(),difference.getGroups(),updates);
            Log.d(TAG,"Difference applied in " + (im.actor.runtime.Runtime.getCurrentTime() - applyStart) + " ms");
            resolver.result(new UpdateProcessed());
            unstashAll();
            isUpdating=false;
          }
        }
).failure(new Consumer<Exception>(){
          @Override public void apply(          Exception e){
            resolver.error(e);
            unstashAll();
            isUpdating=false;
          }
        }
);
      }
    }
);
  }
 else {
    long applyStart=im.actor.runtime.Runtime.getCurrentTime();
    processor.applyDifferenceUpdate(difference.getUsers(),difference.getGroups(),updates);
    Log.d(TAG,"Difference applied in " + (im.actor.runtime.Runtime.getCurrentTime() - applyStart) + " ms");
    return Promises.success(new UpdateProcessed());
  }
}
