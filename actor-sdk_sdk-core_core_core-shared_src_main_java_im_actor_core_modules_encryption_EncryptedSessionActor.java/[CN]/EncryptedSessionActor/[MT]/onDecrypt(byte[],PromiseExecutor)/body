{
  if (session == null) {
    future.error(new RuntimeException("Encryption session is unavailable"));
    return;
  }
  final byte[] senderEphemeralKey=ByteStrings.substring(data,20,32);
  final byte[] receiverEphemeralKey=ByteStrings.substring(data,52,32);
  final int messageIndex=ByteStrings.bytesToInt(data,84);
  EncryptedSessionChain pickedChain=null;
  for (  EncryptedSessionChain c : chains) {
    if (ByteStrings.isEquals(Curve25519.keyGenPublic(c.getOwnPrivateKey()),receiverEphemeralKey)) {
      pickedChain=c;
      break;
    }
  }
  if (pickedChain == null) {
    ask(context().getEncryption().getKeyManager(),new KeyManagerActor.FetchEphemeralPrivateKey(receiverEphemeralKey),new AskCallback(){
      @Override public void onResult(      Object obj){
        final KeyManagerActor.FetchEphemeralPrivateKeyRes theirEphermalKey=(KeyManagerActor.FetchEphemeralPrivateKeyRes)obj;
        spawnChain(theirEphermalKey.getPrivateKey(),senderEphemeralKey);
        onDecrypt(data,future);
      }
      @Override public void onError(      Exception e){
        future.error(e);
      }
    }
);
    return;
  }
  try {
    byte[] decrypted=pickedChain.decrypt(data);
    theirEphemeralKey=senderEphemeralKey;
    future.result(new DecryptedPackage(decrypted));
  }
 catch (  IntegrityException e) {
    e.printStackTrace();
    future.error(e);
  }
}
