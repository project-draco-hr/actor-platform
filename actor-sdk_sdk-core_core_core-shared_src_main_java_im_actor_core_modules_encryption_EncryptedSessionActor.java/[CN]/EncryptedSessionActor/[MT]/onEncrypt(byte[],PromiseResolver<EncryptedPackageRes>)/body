{
  if (session == null) {
    if (isUnavailable) {
      future.error(new RuntimeException("Session is not available"));
    }
 else {
      stash();
    }
    return;
  }
  Promises.success(latestTheirEphemeralKey).mapIfNullPromise(keyManager.supplyUserPreKey(uid,theirKeyGroup)).map(new Function<byte[],EncryptedSessionChain>(){
    @Override public EncryptedSessionChain apply(    byte[] publicKey){
      return pickEncryptChain(publicKey);
    }
  }
).map(new Function<EncryptedSessionChain,EncryptedPackageRes>(){
    @Override public EncryptedPackageRes apply(    EncryptedSessionChain encryptedSessionChain){
      return encrypt(encryptedSessionChain,data);
    }
  }
).pipeTo(future).done(self());
}
