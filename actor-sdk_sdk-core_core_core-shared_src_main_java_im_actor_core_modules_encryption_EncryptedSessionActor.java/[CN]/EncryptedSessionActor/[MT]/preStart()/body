{
  this.keyManager=context().getEncryption().getKeyManagerInt();
  ActorRef keyManager=context().getEncryption().getKeyManager();
  Log.d(TAG,"preStart");
  Promises.tuple(ask(keyManager,new FetchOwnKey()),ask(keyManager,new FetchEphemeralPrivateKeyById(ownKey0)),ask(keyManager,new FetchUserEphemeralKey(uid,theirKeyGroup,theirKey0)),ask(keyManager,new FetchUserKeyGroups(uid))).map(new Function<Tuple4<FetchOwnKeyResult,FetchEphemeralPrivateKeyRes,FetchUserEphemeralKeyResponse,FetchUserKeyGroupsResponse>,EncryptedSession>(){
    @Override public EncryptedSession apply(    Tuple4<FetchOwnKeyResult,FetchEphemeralPrivateKeyRes,FetchUserEphemeralKeyResponse,FetchUserKeyGroupsResponse> res){
      PrivateKey ownIdentityKey=res.getT1().getIdentityKey();
      PrivateKey ownPreKey=new PrivateKey(ownKey0,"curve25519",res.getT2().getPrivateKey());
      PublicKey theirPreKey=res.getT3().getEphemeralKey();
      FetchUserKeyGroupsResponse keyGroups=res.getT4();
      UserKeysGroup keysGroup=null;
      for (      UserKeysGroup g : keyGroups.getUserKeys().getUserKeysGroups()) {
        if (g.getKeyGroupId() == theirKeyGroup) {
          keysGroup=g;
          break;
        }
      }
      if (keysGroup == null) {
        Log.w(TAG,"Their key group not found");
        throw new RuntimeException("Their key group not found");
      }
      PublicKey theirIdentityKey=keysGroup.getIdentityKey();
      return new EncryptedSession(ownIdentityKey,ownPreKey,theirIdentityKey,theirPreKey,theirKeyGroup);
    }
  }
).then(new Consumer<EncryptedSession>(){
    @Override public void apply(    EncryptedSession encryptedSession){
      Log.d(TAG,"Loaded");
      EncryptedSessionActor.this.session=encryptedSession;
      unstashAll();
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
      Log.w(TAG,"Session load error");
      Log.e(TAG,e);
      isFailured=true;
      unstashAll();
    }
  }
).done(self());
}
