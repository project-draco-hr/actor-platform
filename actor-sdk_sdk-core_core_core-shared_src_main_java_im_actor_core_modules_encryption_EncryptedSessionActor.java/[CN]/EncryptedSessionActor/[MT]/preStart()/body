{
  this.keyManager=context().getEncryption().getKeyManagerInt();
  ActorRef keyManager=context().getEncryption().getKeyManager();
  Log.d(TAG,"preStart");
  Promises.tuple(ask(keyManager,new FetchOwnKey()),ask(keyManager,new FetchOwnPreKeyById(ownKey0)),ask(keyManager,new FetchUserPreKey(uid,theirKeyGroup,theirKey0)),ask(keyManager,new FetchUserKeys(uid))).map(new Function<Tuple4<OwnIdentity,PrivateKey,PublicKey,UserKeys>,EncryptedSession>(){
    @Override public EncryptedSession apply(    Tuple4<OwnIdentity,PrivateKey,PublicKey,UserKeys> res){
      PrivateKey ownIdentityKey=res.getT1().getIdentityKey();
      PrivateKey ownPreKey=res.getT2();
      PublicKey theirPreKey=res.getT3();
      UserKeys keyGroups=res.getT4();
      UserKeysGroup keysGroup=null;
      for (      UserKeysGroup g : keyGroups.getUserKeysGroups()) {
        if (g.getKeyGroupId() == theirKeyGroup) {
          keysGroup=g;
          break;
        }
      }
      if (keysGroup == null) {
        Log.w(TAG,"Their key group not found");
        throw new RuntimeException("Their key group not found");
      }
      PublicKey theirIdentityKey=keysGroup.getIdentityKey();
      return new EncryptedSession(ownIdentityKey,ownPreKey,theirIdentityKey,theirPreKey,theirKeyGroup);
    }
  }
).then(new Consumer<EncryptedSession>(){
    @Override public void apply(    EncryptedSession encryptedSession){
      Log.d(TAG,"Loaded");
      EncryptedSessionActor.this.session=encryptedSession;
      unstashAll();
    }
  }
).failure(new Consumer<Exception>(){
    @Override public void apply(    Exception e){
      Log.w(TAG,"Session load error");
      Log.e(TAG,e);
      isUnavailable=true;
      unstashAll();
    }
  }
).done(self());
}
