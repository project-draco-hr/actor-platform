{
  if (session == null) {
    if (isFailured) {
      future.error(new RuntimeException("Session is not available"));
    }
 else {
      stash();
    }
    return;
  }
  Log.w(TAG,"onDecrypt");
  final byte[] senderEphemeralKey=ByteStrings.substring(data,20,32);
  final byte[] receiverEphemeralKey=ByteStrings.substring(data,52,32);
  pickDecryptChain(senderEphemeralKey,receiverEphemeralKey).map(new Function<EncryptedSessionChain,DecryptedPackage>(){
    @Override public DecryptedPackage apply(    EncryptedSessionChain encryptedSessionChain){
      return decrypt(encryptedSessionChain,data);
    }
  }
).pipeTo(future).then(new Consumer<DecryptedPackage>(){
    @Override public void apply(    DecryptedPackage decryptedPackage){
      latestTheirEphemeralKey=senderEphemeralKey;
    }
  }
).done(self());
}
