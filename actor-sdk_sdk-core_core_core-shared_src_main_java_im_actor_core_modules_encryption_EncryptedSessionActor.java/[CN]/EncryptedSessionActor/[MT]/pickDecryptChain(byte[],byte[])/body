{
  EncryptedSessionChain pickedChain=null;
  for (  EncryptedSessionChain c : decryptionChains) {
    if (ByteStrings.isEquals(Curve25519.keyGenPublic(c.getOwnPrivateKey()),ephemeralKey)) {
      pickedChain=c;
      break;
    }
  }
  return Promises.success(pickedChain).mapPromise(new Function<EncryptedSessionChain,Promise<EncryptedSessionChain>>(){
    @Override public Promise<EncryptedSessionChain> apply(    EncryptedSessionChain src){
      if (src != null) {
        return Promises.success(src);
      }
      return ask(context().getEncryption().getKeyManager(),new FetchEphemeralPrivateKey(ephemeralKey)).map(new Function<FetchEphemeralPrivateKeyRes,EncryptedSessionChain>(){
        @Override public EncryptedSessionChain apply(        FetchEphemeralPrivateKeyRes src){
          EncryptedSessionChain chain=new EncryptedSessionChain(session,src.getPrivateKey(),theirEphemeralKey);
          decryptionChains.add(0,chain);
          if (decryptionChains.size() > MAX_DECRYPT_CHAINS) {
            decryptionChains.remove(MAX_DECRYPT_CHAINS).safeErase();
          }
          return chain;
        }
      }
);
    }
  }
);
}
