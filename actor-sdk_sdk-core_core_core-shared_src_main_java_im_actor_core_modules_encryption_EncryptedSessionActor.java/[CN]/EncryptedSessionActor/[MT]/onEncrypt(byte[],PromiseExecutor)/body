{
  if (session == null) {
    future.error(new RuntimeException("Encryption session is unavailable"));
    return;
  }
  if (theirEphemeralKey == null) {
    ask(context().getEncryption().getKeyManager(),new KeyManagerActor.FetchUserEphemeralKeyRandom(uid,theirKeyGroup),new AskCallback(){
      @Override public void onResult(      Object obj){
        KeyManagerActor.FetchUserEphemeralKeyResponse response=(KeyManagerActor.FetchUserEphemeralKeyResponse)obj;
        if (theirEphemeralKey == null) {
          theirEphemeralKey=response.getEphemeralKey().getPublicKey();
        }
        onEncrypt(data,future);
      }
      @Override public void onError(      Exception e){
        future.error(e);
      }
    }
);
    return;
  }
  if (chains.size() == 0) {
    spawnChain(Curve25519.keyGenPrivate(Crypto.randomBytes(32)),theirEphemeralKey);
  }
  try {
    future.result(new EncryptedPackageRes(chains.get(0).encrypt(data)));
  }
 catch (  IntegrityException e) {
    e.printStackTrace();
    future.error(e);
  }
}
