{
  int seq=message.seq;
  byte[] state=message.state;
  if (seq <= updateState.getState().getSeq()) {
    if (LOG_ENABLED) {
      Logger.d(TAG,TAG_PREFIX + "Ignored SeqUpdate {seq:" + seq+ "}");
    }
    return;
  }
  if (LOG_ENABLED) {
    Logger.d(TAG,TAG_PREFIX + "SeqUpdate {seq:" + seq+ "}");
  }
  if (isInvalidated) {
    if (LOG_ENABLED) {
      Logger.d(TAG,TAG_PREFIX + "caching in further map");
    }
    further.put(seq,message);
    return;
  }
  if (!isValidSeq(seq)) {
    Logger.w(TAG,TAG_PREFIX + "Out of sequence: starting timer for invalidation");
    further.put(seq,message);
    self().sendOnce(new InvalidateForced(),2 * 1000L);
    return;
  }
  if (causesInvalidation(message.update)) {
    Logger.w(TAG,TAG_PREFIX + "Message causes invalidation");
    invalidate();
    return;
  }
  if (LOG_ENABLED) {
    Logger.d(TAG,"Processing message");
  }
  if (message instanceof SeqFatUpdate) {
    SeqFatUpdate fatSeqUpdate=(SeqFatUpdate)message;
    if (fatSeqUpdate.users.size() > 0) {
      UserActor.userActor().onUpdateUsers(fatSeqUpdate.users);
    }
 else     if (fatSeqUpdate.groups.size() > 0) {
      GroupsActor.groupUpdates().onUpdateGroups(fatSeqUpdate.groups);
    }
  }
  system().actorOf(UpdateBroker.sequenceBroker()).send(message.update);
  updateState.setState(seq,state);
  if (LOG_ENABLED) {
    Logger.d(TAG,TAG_PREFIX + "Saved state {seq:" + seq+ "}");
  }
  validated();
  self().sendOnce(new InvalidateForced(),24 * 60 * 60* 1000L);
}
