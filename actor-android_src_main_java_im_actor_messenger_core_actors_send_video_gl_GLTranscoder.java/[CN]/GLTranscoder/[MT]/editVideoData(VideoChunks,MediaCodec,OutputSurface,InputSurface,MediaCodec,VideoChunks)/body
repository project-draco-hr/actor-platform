{
  final int TIMEOUT_USEC=10000;
  ByteBuffer[] decoderInputBuffers=decoder.getInputBuffers();
  ByteBuffer[] encoderOutputBuffers=encoder.getOutputBuffers();
  MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();
  int inputChunk=0;
  int outputCount=0;
  boolean outputDone=false;
  boolean inputDone=false;
  boolean decoderDone=false;
  while (!outputDone) {
    if (!inputDone) {
      int inputBufIndex=decoder.dequeueInputBuffer(TIMEOUT_USEC);
      if (inputBufIndex >= 0) {
        if (inputChunk == inputData.getNumChunks()) {
          decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);
          inputDone=true;
        }
 else {
          ByteBuffer inputBuf=decoderInputBuffers[inputBufIndex];
          inputBuf.clear();
          inputData.getChunkData(inputChunk,inputBuf);
          int flags=inputData.getChunkFlags(inputChunk);
          long time=inputData.getChunkTime(inputChunk);
          decoder.queueInputBuffer(inputBufIndex,0,inputData.getChunkSize(inputChunk),time,flags);
          inputChunk++;
        }
      }
 else {
      }
    }
    boolean decoderOutputAvailable=!decoderDone;
    boolean encoderOutputAvailable=true;
    while (decoderOutputAvailable || encoderOutputAvailable) {
      int encoderStatus=encoder.dequeueOutputBuffer(info,TIMEOUT_USEC);
      if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
        encoderOutputAvailable=false;
      }
 else       if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
        encoderOutputBuffers=encoder.getOutputBuffers();
      }
 else       if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
        MediaFormat newFormat=encoder.getOutputFormat();
        outputData.setMediaFormat(newFormat);
      }
 else       if (encoderStatus < 0) {
      }
 else {
        ByteBuffer encodedData=encoderOutputBuffers[encoderStatus];
        if (encodedData == null) {
        }
        if (info.size != 0) {
          encodedData.position(info.offset);
          encodedData.limit(info.offset + info.size);
          outputData.addChunk(encodedData,info.size,info.flags,info.presentationTimeUs);
          outputCount++;
        }
        outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
        encoder.releaseOutputBuffer(encoderStatus,false);
      }
      if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
        continue;
      }
      if (!decoderDone) {
        int decoderStatus=decoder.dequeueOutputBuffer(info,TIMEOUT_USEC);
        if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
          decoderOutputAvailable=false;
        }
 else         if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
        }
 else         if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
        }
 else         if (decoderStatus < 0) {
        }
 else {
          boolean doRender=(info.size != 0);
          decoder.releaseOutputBuffer(decoderStatus,doRender);
          if (doRender) {
            outputSurface.awaitNewImage();
            outputSurface.drawImage();
            inputSurface.setPresentationTime(info.presentationTimeUs * 1000);
            inputSurface.swapBuffers();
          }
          if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
            encoder.signalEndOfInputStream();
          }
        }
      }
    }
  }
}
