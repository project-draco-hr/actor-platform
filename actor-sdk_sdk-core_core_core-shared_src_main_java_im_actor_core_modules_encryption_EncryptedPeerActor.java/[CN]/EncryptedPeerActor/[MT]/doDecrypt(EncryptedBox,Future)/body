{
  final int senderKeyGroup=ByteStrings.bytesToInt(ByteStrings.substring(data.getEncryptedPackage(),0,4));
  final byte[] encPackage=ByteStrings.substring(data.getEncryptedPackage(),4,data.getEncryptedPackage().length - 4);
  if (sessions.containsKey(senderKeyGroup)) {
    Log.d(TAG,"Decryption with key group #" + senderKeyGroup);
    byte[] encKey=null;
    for (    EncryptedBoxKey k : data.getKeys()) {
      if (k.getKeyGroupId() == ownKeyGroupId && k.getUid() == myUid()) {
        encKey=k.getEncryptedKey();
        break;
      }
    }
    if (encKey == null) {
      Log.d(TAG,"Unable to find encryption key in key group");
      return;
    }
    Log.d(TAG,"EncPackage: " + Hex.toHex(encPackage));
    Log.d(TAG,"EncKey: " + Hex.toHex(encKey));
    ask(sessions.get(senderKeyGroup),new EncryptedSessionActor.DecryptPackage(encKey),new AskCallback(){
      @Override public void onResult(      Object obj){
        Log.d(TAG,"Decryption with key group:onResult");
        EncryptedSessionActor.DecryptedPackage decryptedPackage=(EncryptedSessionActor.DecryptedPackage)obj;
        byte[] encData;
        try {
          encData=ActorBox.openBox(ByteStrings.intToBytes(senderKeyGroup),encPackage,new ActorBoxKey(decryptedPackage.getData()));
          ApiMessage message=ApiMessage.fromBytes(encData);
          Log.d(TAG,"Box open:" + message);
        }
 catch (        IOException e) {
          e.printStackTrace();
          future.onError(e);
          return;
        }
        future.onResult();
      }
      @Override public void onError(      Exception e){
        Log.d(TAG,"Decryption with key group:onError");
        future.onError(e);
      }
    }
);
  }
 else {
    Log.w(TAG,"Unable to find appropriate session #" + senderKeyGroup);
    future.onError(new RuntimeException());
  }
}
