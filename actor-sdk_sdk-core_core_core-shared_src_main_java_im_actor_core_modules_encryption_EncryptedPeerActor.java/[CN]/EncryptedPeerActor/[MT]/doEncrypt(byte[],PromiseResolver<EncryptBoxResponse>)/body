{
  if (!isReady) {
    stash();
    return;
  }
  final byte[] encKey=Crypto.randomBytes(128);
  Log.d(TAG,"doEncrypt");
  final long start=Runtime.getActorTime();
  PromisesArray.of(theirKeys.getUserKeysGroups()).mapOptional(new Function<UserKeysGroup,Promise<SessionActor>>(){
    @Override public Promise<SessionActor> apply(    UserKeysGroup keysGroup){
      Log.d(TAG,"Key Group " + keysGroup.getKeyGroupId());
      if (activeSessions.containsKey(keysGroup.getKeyGroupId())) {
        return success(activeSessions.get(keysGroup.getKeyGroupId()).getSessions().get(0));
      }
      return context().getEncryption().getSessionManagerInt().pickSession(uid,keysGroup.getKeyGroupId()).map(new Function<PeerSession,SessionActor>(){
        @Override public SessionActor apply(        PeerSession src){
          return spawnSession(src);
        }
      }
).log(TAG + ":session#" + keysGroup.getKeyGroupId());
    }
  }
).mapOptional(new Function<SessionActor,Promise<EncryptedSessionActor.EncryptedPackageRes>>(){
    @Override public Promise<EncryptedSessionActor.EncryptedPackageRes> apply(    SessionActor sessionActor){
      return ask(sessionActor.getActorRef(),new EncryptedSessionActor.EncryptPackage(encKey));
    }
  }
).zip().map(new Function<EncryptedSessionActor.EncryptedPackageRes[],EncryptBoxResponse>(){
    @Override public EncryptBoxResponse apply(    EncryptedSessionActor.EncryptedPackageRes[] src){
      if (src.length == 0) {
        throw new RuntimeException("No sessions available");
      }
      Log.d(TAG,"Keys Encrypted in " + (Runtime.getActorTime() - start) + " ms");
      ArrayList<EncryptedBoxKey> encryptedKeys=new ArrayList<>();
      for (      EncryptedSessionActor.EncryptedPackageRes r : src) {
        Log.d(TAG,"Keys: " + r.getKeyGroupId());
        encryptedKeys.add(new EncryptedBoxKey(uid,r.getKeyGroupId(),"curve25519",r.getData()));
      }
      byte[] encData;
      try {
        encData=ActorBox.closeBox(ByteStrings.intToBytes(ownKeyGroupId),data,Crypto.randomBytes(32),new ActorBoxKey(encKey));
      }
 catch (      IntegrityException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
      Log.d(TAG,"All Encrypted in " + (Runtime.getActorTime() - start) + " ms");
      return new EncryptBoxResponse(new EncryptedBox(encryptedKeys.toArray(new EncryptedBoxKey[encryptedKeys.size()]),ByteStrings.merge(ByteStrings.intToBytes(ownKeyGroupId),encData)));
    }
  }
).pipeTo(future).done(self());
}
