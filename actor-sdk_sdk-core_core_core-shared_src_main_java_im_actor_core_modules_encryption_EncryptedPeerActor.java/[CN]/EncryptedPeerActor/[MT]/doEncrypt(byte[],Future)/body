{
  Log.d(TAG,"doEncrypt");
  ask(context().getEncryption().getKeyManager(),new KeyManagerActor.FetchUserKeyGroups(uid),new AskCallback(){
    @Override public void onResult(    Object obj){
      KeyManagerActor.FetchUserKeyGroupsResponse r=(KeyManagerActor.FetchUserKeyGroupsResponse)obj;
      UserKeysGroup[] keysGroups=r.getUserKeys().getUserKeysGroups();
      ArrayList<ActorRef> sessions=new ArrayList<ActorRef>();
      outer:       for (      final UserKeysGroup g : keysGroups) {
        for (        SessionId sessionId : activeSessions.keySet()) {
          if (sessionId.getTheirKeyGroupId() == g.getKeyGroupId()) {
            sessions.add(activeSessions.get(sessionId));
            continue outer;
          }
        }
        Log.d(TAG,"doEncrypt:session not found for #" + g.getKeyGroupId());
        ask(context().getEncryption().getKeyManager(),new KeyManagerActor.FetchUserEphemeralKeyRandom(uid,g.getKeyGroupId()),new AskCallback(){
          @Override public void onResult(          Object obj){
            final KeyManagerActor.FetchUserEphemeralKeyResponse r=(KeyManagerActor.FetchUserEphemeralKeyResponse)obj;
            Log.d(TAG,"doEncrypt:#" + g.getKeyGroupId() + " Their key ok: "+ r.getEphemeralKey().getKeyId());
            ask(context().getEncryption().getKeyManager(),new KeyManagerActor.FetchOwnEphemeralKey(),new AskCallback(){
              @Override public void onResult(              Object obj){
                final KeyManagerActor.FetchOwnEphemeralKeyResult res=(KeyManagerActor.FetchOwnEphemeralKeyResult)obj;
                Log.d(TAG,"doEncrypt:#" + g.getKeyGroupId() + " Own key ok: "+ res.getId());
                SessionId sessionId=new SessionId(ownKeyGroupId,res.getId(),g.getKeyGroupId(),r.getEphemeralKey().getKeyId());
                activeSessions.put(sessionId,system().actorOf(Props.create(EncryptedSessionActor.class,new ActorCreator<EncryptedSessionActor>(){
                  @Override public EncryptedSessionActor create(){
                    return new EncryptedSessionActor(context(),uid,res.getId(),r.getEphemeralKey().getKeyId(),g.getKeyGroupId());
                  }
                }
),getPath() + "/k_" + RandomUtils.nextRid()));
                doEncrypt(data,future);
              }
              @Override public void onError(              Exception e){
                Log.d(TAG,"doEncrypt:#" + g.getKeyGroupId() + " Own key error");
                future.onError(e);
              }
            }
);
          }
          @Override public void onError(          Exception e){
            Log.d(TAG,"doEncrypt:#" + g.getKeyGroupId() + " Their key error");
            future.onError(e);
          }
        }
);
        return;
      }
      Log.d(TAG,"doEncrypt: all sessions created");
    }
    @Override public void onError(    Exception e){
      future.onError(e);
    }
  }
);
  final byte[] encKey=Crypto.randomBytes(128);
  final ArrayList<EncryptedBoxKey> encryptedKeys=new ArrayList<EncryptedBoxKey>();
  for (  final SessionId sessionId : activeSessions.keySet()) {
    ask(activeSessions.get(sessionId),new EncryptedSessionActor.EncryptPackage(encKey),new AskCallback(){
      @Override public void onResult(      Object obj){
        EncryptedSessionActor.EncryptedPackageRes res=(EncryptedSessionActor.EncryptedPackageRes)obj;
        encryptedKeys.add(new EncryptedBoxKey(uid,sessionId.getTheirKeyGroupId(),res.getData()));
        if (encryptedKeys.size() == activeSessions.size()) {
          doEncrypt(encKey,data,encryptedKeys,future);
        }
      }
      @Override public void onError(      Exception e){
        future.onError(e);
      }
    }
);
  }
}
